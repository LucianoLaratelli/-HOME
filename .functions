#!/usr/bin/env bash

# Create a new directory and enter it
system=$(uname -s)
#mac specific commands
if [ "$system" = "Darwin" ]; then
	# `o` with no arguments opens the current directory, otherwise opens the given
	# location
	function o() {
		if [ $# -eq 0 ]; then
			open .;
		else
			open "$@";
		fi;
	}
fi
if [ "$system" = "Linux" ]; then
	function o() {
		if [ $# -eq 0 ]; then
			xdg-open .;
		else
			xdg-open "$@";
		fi;
	}
fi

function mkd() {
	mkdir -p "$@" && cd "$_";
}

# Use Gitâ€™s colored diff when available
hash git &>/dev/null;
if [ $? -eq 0 ]; then
	function diff() {
		git diff --no-index --color-words "$@";
	}
fi;

# `v` with no arguments opens the current directory in Vim, otherwise opens the
# given location
function v() {
	if [ $# -eq 0 ]; then
		vim .;
	else
		vim "$@";
	fi;
}


# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
	tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}

function grep() {
	echo "Use rg"
}

function rg(){
	#because I use $HOME as a git directory (and therefore have a .gitignore in $HOME),
	#rg's default respect of whatever gitignore it finds can get annoying
	#this will find the closest gitignore to the current directory, then
	#add flags to rg based on which gitignore is found
	#CAVEATS:
	#    rg must exist at /usr/bin/rg
	#    

	GITIGNORE=".gitignore"
	START="$(pwd)"
	if [ "${PWD}" == "${HOME}" ]; then #bail early if we're home
		/usr/bin/rg "$@" --no-ignore
	else
		if [ -f "${GITIGNORE}" ]; then
			/usr/bin/rg "$@" 
		else
			while [ ! -f "${GITIGNORE}" ];
			do
				cd ..
			done
			if [ "${PWD}" == "${HOME}" ]; then 
				cd "${START}" || echo "rg function failed to find ${START}" 
				/usr/bin/rg "$@" --no-ignore
			else
				/usr/bin/rg "$@"
			fi
		fi 
	fi
		
}
